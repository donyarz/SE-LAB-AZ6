# SE-LAB-AZ6
فاز اول آرمایش در برنچ main قرار دارد و فاز دوم در برنچ project2

# فاز اول آزمایش

### پیاده‌سازی الگوی استراتژی با رویکرد توسعه آزمون‌محور (TDD)

در این پروژه، ما از الگوی طراحی استراتژی برای مدیریت مختلف روش‌های سفر و محاسبه زمان سفر بین شهرها استفاده کردیم. به این منظور، یک رابط به نام `TravelStrategy` تعریف شد که دو پیاده‌سازی مختلف دارد: `TrainTravelStrategy` برای محاسبه زمان سفر با قطار و `BusTravelStrategy` برای محاسبه زمان سفر با اتوبوس.

#### رویکرد آزمون‌محور (TDD)
رویکرد توسعه آزمون‌محور به ما کمک کرد تا قبل از نوشتن کد اصلی، آزمون‌هایی را برای تایید عملکرد مورد نظر بنویسیم. این آزمون‌ها شامل موارد زیر بودند:

**دو آزمون برای استراتژی قطار**: ابتدا آزمون‌هایی نوشته شد که بررسی می‌کرد زمان مورد انتظار سفر با قطار بین دو گره را محاسبه کند. این آزمون‌ها شکست خورده و نشان‌دهنده نیاز به پیاده‌سازی منطق محاسبه زمان سفر بودند.
   
**آزمون برای استراتژی اتوبوس**: مشابه با قطار، آزمون‌هایی برای بررسی عملکرد استراتژی اتوبوس نوشته شد. این آزمون‌ها به بررسی پیاده‌سازی صحیح محاسبه زمان سفر با توجه به وزن یال‌ها (که نمایانگر زمان است) پرداختند.

**پیاده‌سازی و تکرار**: پس از نوشتن هر آزمون، منطق مربوطه در کلاس‌های استراتژی پیاده‌سازی شد تا آزمون‌ها پاس شوند.

در عکس‌های زیر می‌توانید مراحل رویکرد توسعه آزمون‌محور را ببینید: <br> <br>
![5](https://github.com/user-attachments/assets/1b99887f-5801-4758-8c33-f82a8c20af98)
<br> <br>
سپس بعد از این مسئله قالب کلی کلاس را پیاده‌سازی کردیم: <br> <br>
![2](https://github.com/user-attachments/assets/e05b5d8c-b3ad-44f3-8591-4a039d6e1156)
![3](https://github.com/user-attachments/assets/e70bfbd3-2811-427d-98cc-248cf94f8e19)
<br> <br>
بعد از این تست‌ها را مجددا ران کردیم تا خطاهای زمان رانتایم مشخص شوند: <br> <br>
![1](https://github.com/user-attachments/assets/090adbd6-9412-45a1-aa72-aa5f281b4019)
<br> <br>
حال با توجه به این خطاها متدها را کامل کردیم که نتیجه‌ی اجرای مجدد آن‌ها را در زیر مشاهده می‌کنید: <br> <br>
![4](https://github.com/user-attachments/assets/24c7a540-7f20-4a93-bba2-32ae56723bc2)
<br> <br>
ما از الگوی طراحی استراتژی در پروژه استفاده کردیم تا بتوانیم روش‌های مختلف سفر و محاسبه زمان سفر بین شهرها را به صورت منعطف و قابل تعویض در زمان اجرا پیاده‌سازی کنیم. با تعریف رابط `TravelStrategy` و پیاده‌سازی‌های متفاوت آن برای قطار و اتوبوس، توانستیم رفتار محاسباتی مورد نظر را در قالب استراتژی‌های جداگانه ایزوله کرده و به کاربر اجازه دهیم تا بر اساس نیاز خود، روش محاسبه زمان سفر را انتخاب کند. این قابلیت تغییر رفتار محاسباتی بدون تغییر در کد اصلی نرم‌افزار و با استفاده از تزریق وابستگی، نشان‌دهنده موفقیت ما در پیاده‌سازی الگوی استراتژی است. این الگو نه تنها به ما امکان داد تا کد را با انعطاف بیشتری بنویسیم، بلکه به افزایش قابلیت نگهداری و تست‌پذیری کد نیز کمک کرد. <br> <br>

### پیاده‌سازی الگوی حالت یا وضعیت با رویکرد توسعه آزمون‌محور (TDD)

در پروژه ما، برای مدیریت حالت‌های مختلف مسیرهای میان شهرها از الگوی طراحی وضعیت (State) استفاده شد. این الگو به ما اجازه داد تا تغییرات حالت مسیرها، مانند تغییر بین "یک‌طرفه" و "دوطرفه"، را به صورت دینامیک و بدون نیاز به تغییر در ساختار اصلی کد انجام دهیم. برای پیاده‌سازی این الگو، از یک کلاس `enum` به نام `RouteState` استفاده کردیم که حالت‌های مختلف مسیر را شامل می‌شد. 

رویکرد توسعه آزمون‌محور (TDD) به ما کمک کرد تا ابتدا آزمون‌هایی برای بررسی تغییرات حالت بنویسیم. این آزمون‌ها به ما امکان داد تا رفتار مورد انتظار در هنگام تغییر وضعیت مسیرها را مشخص کنیم. به عنوان مثال، آزمون‌هایی نوشتیم که بررسی می‌کردند آیا مسیرها به درستی از حالت "دوطرفه" به "یک‌طرفه" تغییر می‌کنند و بالعکس.

پس از نوشتن این آزمون‌ها و اجرای آن‌ها، مشاهده شد که آزمون‌ها به دلیل نبود منطق مورد نیاز برای تغییر حالت‌ها شکست می‌خورند. در این مرحله، منطق مورد نیاز در کلاس `RouteManager` پیاده‌سازی شد. این کلاس شامل متدهایی مانند `setOneWay()` و `setTwoWay()` بود که با استفاده از آن‌ها می‌توانستیم حالت مسیرها را تغییر دهیم. همچنین، متدی به نام `updateRoutes()` برای اعمال تغییرات حالت‌ها بر روی تمامی مسیرها اضافه شد که بر اساس حالت جاری (`RouteState`) عمل می‌کرد.

هر بار پس از پیاده‌سازی منطق جدید، آزمون‌ها مجددا اجرا شدند تا اطمینان حاصل شود که تغییرات به درستی اعمال می‌شوند. با موفقیت‌آمیز بودن این آزمون‌ها، مطمئن شدیم که الگوی وضعیت به درستی پیاده‌سازی شده و تمامی حالات مسیرها به درستی مدیریت می‌شوند. استفاده از `enum` برای تعریف حالات مختلف نیز به ما کمک کرد تا کد تمیزتر و قابل نگهداری‌تری داشته باشیم و تغییرات در حالت‌ها را به راحتی مدیریت کنیم.

در عکس‌های زیر می‌توانید مراحل رویکرد توسعه آزمون‌محور را ببینید: <br> <br>
![image](https://github.com/user-attachments/assets/0bae1f79-be2d-4aa8-9d6f-78ac9b84ca16)
<br> <br>
سپس بعد از این مسئله قالب کلی کلاس را پیاده‌سازی کردیم: <br> <br>
![image](https://github.com/user-attachments/assets/14c5b551-6260-4bf9-b82c-5ae4be34a1c5)
![image](https://github.com/user-attachments/assets/cdfb4667-ced6-46d2-9788-1f3c52fe7436)
<br> <br>
بعد از این تست‌ها را مجددا ران کردیم تا خطاهای زمان رانتایم مشخص شوند: <br> <br>
![image](https://github.com/user-attachments/assets/566983b4-c4f1-44f3-983b-72eb4e7148fb)
![image](https://github.com/user-attachments/assets/0a588e03-0dcd-4884-bdf3-7242c41c2fb0)
<br> <br>
حال با توجه به این خطاها متدها را کامل کردیم که نتیجه‌ی اجرای مجدد آن‌ها را در زیر مشاهده می‌کنید: <br> <br>
![21](https://github.com/user-attachments/assets/8ece53c8-d873-4c4a-a075-1b10cd70a0b3)
<br> <br>
ما از الگوی طراحی وضعیت برای مدیریت تغییرات حالت مسیرها در پروژه استفاده کردیم و موفق شدیم این الگو را به طور کامل پیاده‌سازی کنیم. دلیل این موفقیت این است که توانستیم تغییر حالت‌ها را به سادگی و بدون نیاز به تغییرات عمده در کد اصلی، با استفاده از کلاس `RouteManager` و `enum` مرتبط با آن انجام دهیم. آزمون‌های متعددی که بر اساس رویکرد TDD نوشته و اجرا شدند، نشان دادند که تغییرات حالت به درستی اعمال شده و تمامی مسیرها مطابق انتظار به روزرسانی می‌شوند. این اطمینان از عملکرد صحیح، به ما نشان می‌دهد که الگوی وضعیت به طور موثر در این پروژه محقق شده است. <br> <br>


### تست کردن الگوریتم‌های گراف

در میان تست‌های بالا متوجه شدیم که یک تست به درستی جواب نمی‌دهد حال آنکه به نظر می‌رسید تمام منطق مورد نیاز تست‌ها به درستی پیاده‌سازی شده‌اند. پس از بررسی‌های بیشتر متوجه شدیم که ایراد از کلاس‌های جدید و متدهای نوشته شده‌ی آن‌ها نیست بلکه مشکل بخاطر نوع پیاده‌سازی الگوریتم‌های گراف در کلاس گراف بوده است. مشکل در بخش انتهایی که که مربوط به پیدا کردن مسیری که از شهر مورد نفرت عبور نکند بود. پس با توجه به رویکرد توسعه آزمون محور برای این دو الگوریتم در این رابطه تست‌هایی نوشتیم که در عکس زیر مشاهده می‌کنید: <br> <br>
![image](https://github.com/user-attachments/assets/d042dd97-f47e-4b35-be29-f835b8f4a3bb)
<br> <br>
همانطور که مشاهده می‌کنید تست‌ها فیل شدند. پس الگوریتم‌ها را اصلاح کردیم و تست‌ها را مجددا ران کردیم که نتیجه مانند تصویر زیر شد: <br> <br>
![image](https://github.com/user-attachments/assets/e9952998-d740-4dad-92b2-7cefffbd01db)
<br> <br>
### پیاده‌سازی کلاس Main با رویکرد توسعه آزمون‌محور (TDD)

کلاس `Main` در این پروژه به عنوان رابط کاربری اصلی عمل می‌کند و وظیفه مدیریت تعاملات کاربر با سیستم را بر عهده دارد. این کلاس ورودی‌های کاربر را دریافت می‌کند و با استفاده از متدهای مختلف، عملیات‌های مربوط به مدیریت مسیرها و محاسبه زمان سفر را انجام می‌دهد. این کلاس خود به طور مستقیم منطق پیچیده‌ای را پیاده‌سازی نمی‌کند، بلکه از سایر کلاس‌ها و استراتژی‌ها برای انجام محاسبات و تغییرات استفاده می‌کند.

کلاس `Main` شامل چندین متد کلیدی است که هر کدام وظیفه خاصی را بر عهده دارند. مهم‌ترین متد این کلاس، متد `main` است که به عنوان نقطه شروع برنامه عمل می‌کند. این متد ابتدا نقشه شهر و مسیرها را از کاربر دریافت می‌کند و سپس بر اساس نوع کاربر (استاندار یا شهروند)، منوی مربوطه را نمایش می‌دهد. بسته به انتخاب کاربر، متدهای مختلفی مانند `handleMayorActions` و `handleCitizenActions` فراخوانی می‌شوند.

متد `handleMayorActions` وظیفه مدیریت عملیات‌های مربوط به استاندار را دارد. این عملیات‌ها شامل تغییر وضعیت مسیرها بین یک‌طرفه و دوطرفه، و همچنین تنظیم سرعت قطارها است. این متد از کلاس `RouteManager` برای اعمال تغییرات در وضعیت مسیرها استفاده می‌کند.

متد `handleCitizenActions` نیز به شهروندان اجازه می‌دهد تا اطلاعات مربوط به زمان سفر را بر اساس استراتژی‌های مختلف (مانند استفاده از قطار یا اتوبوس) دریافت کنند. این متد از استراتژی‌های `TrainTravelStrategy` و `BusTravelStrategy` برای محاسبه زمان سفر استفاده می‌کند و نتایج را به کاربر نمایش می‌دهد.

همچنین، متد `createCityMapFromUserInput` برای دریافت نقشه شهر و مسیرها از کاربر و ساخت گراف مربوطه به کار می‌رود. این متد اطلاعات مربوط به شهرها و مسیرها را از کاربر می‌گیرد و گراف را با استفاده از کلاس‌های `Node` و `Edge` ایجاد می‌کند.

در نهایت، کلاس `Main` بیشتر به عنوان رابط کاربری عمل می‌کند و وظیفه اصلی آن هدایت کاربران به متدهای صحیح و نمایش نتایج به آن‌هاست، در حالی که منطق اصلی توسط سایر کلاس‌ها و استراتژی‌ها پیاده‌سازی می‌شود.

این کلاس‌ هم مانند موارد قبلی با رویکرد توسعه آزمون‌محور ایجاد شده است که نهایتا نتایج تست‌های آن را در تصویر زیر مشاهده می‌کنید: <br> <br>
![image](https://github.com/user-attachments/assets/71f502df-742c-427a-8b18-f5d3b4503a8d)
<br> <br>
نهایتا تصویری از پوشش تست‌ها آورده شده که حائز اهمیت است: <br> <br>
![image](https://github.com/user-attachments/assets/ea739d6e-ac94-4a9f-ae71-4a0160e00625)
<br> <br>
همانطور که مشاهده می‌کنید همه‌ی کلاس‌ها و متدها را تست‌ها پوشش داده‌اند. تنها در کلاس Main پوشش کامل نیست و آن هم به این علت است که بخش خوبی از کدهای تست نشده برای تابع main هستند که تست نشده است که نیازی به این کار نیست زیرا صرفا تابع‌ها را صدا می‌زند. بخش اندک دیگری نیز هست که به این خاطر تست نشده‌اند که عملا توابعی که صدا می‌زنند و یا نتایجی که برمی‌گردانند در کلاس‌های دیگر و کلاس‌های تست مخصوص آن‌ها تست شده است. <br> <br>

## نتایج

برای این بخش یک فایل تکست به نام `result.txt` به بخش پوشه گراف پروژه اضافه شده است که خروجی یکبار ران کردن سیستم و کار کردن با آن و تست کردن حالات مختلف است. همچنین می‌توانید خودتان پروژه را ران کنید و با رابط کاربری آن ارتباط برقرار کنید و آن را تست کنید. (همانطور که در فایل تکست هم مشاهده می‌کنید سوالات و گزینه‌ها کاملا واضح هستند که مشکلی در برقراری ارتباط پیش نیاید.) <br> <br>

# فاز دوم آزمایش 


### استفاده از تکنیک **Facade**
دو کلاس `ParserFacade` و `CodeGeneratorFacade` اضافه شده‌اند تا یک رابط ساده برای کلاس‌های `Parser` و `CodeGenerator` فراهم کنند. این تکنیک به مخفی کردن پیچیدگی‌های زیرین کمک می‌کند و باعث می‌شود که کاربران سوم‌شخص تنها با این facade‌ها سر و کار داشته باشند.

### استفاده از تکنیک **State/Strategy** یا **Polymorphism**
در کلاس `SymbolType` از **پلی‌مورفیسم (چندریختی)** استفاده شده است تا نوع متغیر مرتبط با هر نوع سمبل را مشخص کند. به این ترتیب، به جای استفاده از ساختارهای switch-case، از `symbolType.varType` استفاده شده است که کد را تمیزتر و قابل فهم‌تر می‌کند.

### استفاده از تکنیک **Separate Query From Modifier**
در کلاس `Memory`، متدهای `getTemp` و `getDateAddress` هم عملیات جستجو و هم تغییر مقدار را انجام می‌دادند. برای جدا کردن این دو وظیفه، متدهای `updateTempIndex` و `updateDataAddress` اضافه شدند تا عملیات جستجو و تغییر به‌طور مستقل انجام شوند.

### استفاده از تکنیک **Self-Encapsulated Field**
در کلاس `Address`، برای فیلدهای داخلی getterهایی اضافه شد. این getterها هم در داخل کلاس و هم در خارج از کلاس برای دسترسی به فیلدها استفاده می‌شوند. این کار باعث افزایش انسجام و محافظت از فیلدهای داخلی کلاس شده است.

### استفاده از دو تکنیک دیگر

1. در کلاس `Parser`، متدهای `loadRules`، `initializeParser`، `shiftAction` و `reduceAction` از کد اصلی استخراج شدند تا کد ساده‌تر و خواناتر شود.
2. پارامترهای `className` و `methodName` که چندین بار با هم استفاده می‌شدند، در قالب یک کلاس جدید به نام `MethodParameters` ترکیب شدند. این کار باعث سازماندهی بهتر پارامترها در `SymbolTable` شد.
<br><br>
# پرسش ها

## سوال 1

کتاب GoF سه دسته اصلی از الگوهای طراحی را معرفی می‌کند که هر کدام از این دسته‌ها به طور خاص به حل مسائل مختلف در طراحی نرم‌افزار می‌پردازند. این سه دسته شامل الگوهای طراحی سازنده (Creational Patterns)، الگوهای طراحی ساختاری (Structural Patterns)، و الگوهای طراحی رفتاری (Behavioral Patterns) هستند که در ادامه به هر یک از این دسته‌ها پرداخته می‌شود.

الگوهای طراحی سازنده به فرآیند ایجاد و نمونه‌سازی اشیاء در نرم‌افزار می‌پردازند. این الگوها با ارائه روش‌های مختلف برای ایجاد اشیاء، باعث افزایش انعطاف‌پذیری و استفاده مجدد از کدها می‌شوند. در این دسته، الگوهایی مانند Singleton، Factory، Abstract Factory، Builder و Prototype قرار دارند. به عنوان مثال، الگوی Singleton تضمین می‌کند که تنها یک نمونه از یک کلاس ایجاد شود و الگوی Factory مسئولیت ایجاد اشیاء را از کلاس اصلی گرفته و به یک کلاس Factory واگذار می‌کند. این الگوها کمک می‌کنند تا کدهای ما از لحاظ ایجاد اشیاء بسیار منعطف‌تر و قابل نگهداری‌تر شوند.

الگوهای طراحی ساختاری به نحوه ترکیب و ساختاردهی کلاس‌ها و اشیاء می‌پردازند. این الگوها با ترکیب اشیاء به شیوه‌ای مناسب، ساختار برنامه را ساده‌تر و روابط بین اشیاء را بهتر تعریف می‌کنند. در این دسته، الگوهایی مانند Adapter، Composite، Proxy، Flyweight، Facade، Bridge و Decorator قرار دارند. به عنوان مثال، الگوی Adapter برای ایجاد واسط بین دو موجودیت غیرمرتبط استفاده می‌شود تا بتوانند با هم کار کنند، و الگوی Composite برای پیاده‌سازی سلسله مراتب جزء-کل، مانند ساختار درختی، به کار می‌رود. این الگوها با ساده‌سازی ساختار و تعریف واضح‌تر روابط بین اجزا، به توسعه نرم‌افزارهای پیچیده کمک می‌کنند.

الگوهای طراحی رفتاری بر نحوه تعامل و ارتباط بین اشیاء تمرکز دارند و راهکارهایی برای بهبود این تعاملات و افزایش انعطاف‌پذیری در آینده ارائه می‌دهند. این الگوها نحوه ارتباط مؤثر بین اشیاء را تعیین می‌کنند و به کاهش وابستگی‌های بین آن‌ها کمک می‌کنند. از جمله الگوهای مهم در این دسته می‌توان به Template Method، Mediator، Chain of Responsibility، Observer، Strategy، Command، State، Visitor، Interpreter، Iterator و Memento اشاره کرد. به عنوان مثال، الگوی Strategy برای زمانی مناسب است که چندین الگوریتم مختلف برای انجام یک کار وجود دارد و مشتری می‌تواند در زمان اجرا یکی از آن‌ها را انتخاب کند، در حالی که الگوی Observer برای مشاهده تغییرات در وضعیت یک شیء و واکنش به آن‌ها کاربرد دارد. این الگوها به برنامه‌نویسان کمک می‌کنند تا سیستم‌هایی با ارتباطات مؤثر و انعطاف‌پذیر ایجاد کنند که قابلیت گسترش و نگهداری بالایی داشته باشند.

<br><br>

## سوال 2

در فاز اول آزمایش، الگوهای طراحی مورد استفاده در دسته‌ی الگوهای طراحی رفتاری (Behavioral Patterns) قرار می‌گیرند. این الگوها به طور خاص بر تعامل و ارتباط بین اشیاء تمرکز دارند و به ایجاد سیستم‌هایی انعطاف‌پذیر و قابل توسعه کمک می‌کنند.

یکی از الگوهای مورد استفاده، **الگوی استراتژی** (Strategy Pattern) است. این الگو به عنوان یک الگوی رفتاری به کار می‌رود و به ما امکان می‌دهد که مجموعه‌ای از الگوریتم‌های مختلف را تعریف کرده و آن‌ها را به طور مستقل از مشتری انتخاب و استفاده کنیم. در این پروژه، این الگو برای تعریف و مدیریت روش‌های مختلف سفر و محاسبه زمان سفر (مانند استفاده از قطار یا اتوبوس) به کار گرفته شده است. با استفاده از این الگو، ما توانستیم استراتژی‌های مختلفی برای محاسبه زمان سفر پیاده‌سازی کنیم که در زمان اجرا قابل تعویض باشند، بدون اینکه نیازی به تغییر در ساختار اصلی کد باشد.

الگوی دیگر مورد استفاده، **الگوی وضعیت** (State Pattern) است. این الگو نیز جزو الگوهای رفتاری محسوب می‌شود و به ما اجازه می‌دهد تا رفتار یک شیء را بر اساس وضعیت داخلی آن تغییر دهیم. در این پروژه، این الگو برای مدیریت وضعیت مسیرها (مانند حالت "یک‌طرفه" یا "دوطرفه") استفاده شده است. با استفاده از این الگو، ما توانستیم به طور دینامیک و بسته به وضعیت جاری مسیرها، رفتار سیستم را تغییر داده و پاسخ مناسبی به درخواست‌های کاربران بدهیم.

این دو الگو، هر دو در دسته الگوهای رفتاری قرار دارند و به ما کمک کردند تا یک سیستم پویا و انعطاف‌پذیر ایجاد کنیم که بتواند به راحتی با تغییرات وضعیت و نیازهای مختلف کاربران سازگار شود.

<br> <br>

## سوال 3

برای پاسخ به سوال کاربران در شرایطی که مسیرها در هر زمان دقیقاً در یکی از دو حالت "یک‌طرفه" یا "دوطرفه" هستند، الگوی طراحی وضعیت (State) مناسب‌ترین انتخاب است. این الگو به ما اجازه می‌دهد تا با تعریف حالت‌های مختلف، رفتار سیستم را بسته به حالت جاری تغییر دهیم. به عبارت دیگر، این الگو به ما امکان می‌دهد که به طور پویا و در زمان اجرا، وضعیت سیستم را تغییر داده و متناسب با آن، رفتار مورد نظر را اعمال کنیم.

در پروژه ما، دو حالت اصلی برای مسیرها تعریف شده است: "یک‌طرفه" و "دوطرفه". با استفاده از الگوی وضعیت، می‌توانیم به سادگی بین این دو حالت جابجا شویم و برای هر حالت، رفتار مشخصی تعریف کنیم. به عنوان مثال، در حالت "یک‌طرفه"، مسیرها تنها از یک سمت قابل دسترسی هستند و در حالت "دوطرفه"، مسیرها از هر دو سمت قابل استفاده خواهند بود. 

برای تحقق این الگو، ابتدا یک کلاس `enum` به نام `RouteState` تعریف شد که دو حالت "ONE_WAY" و "TWO_WAY" را شامل می‌شود. سپس یک کلاس `RouteManager` پیاده‌سازی شد که مسئول مدیریت و تغییر حالت‌ها است. این کلاس متدهایی مانند `setOneWay()` و `setTwoWay()` را ارائه می‌دهد که با فراخوانی آن‌ها، می‌توان حالت مسیرها را تغییر داد. همچنین، متدی به نام `updateRoutes()` وجود دارد که تغییرات حالت را بر روی تمامی مسیرها اعمال می‌کند. 

در نهایت، هرگاه کاربر درخواستی مبنی بر وضعیت مسیرها ارائه دهد، کلاس `RouteManager` با توجه به حالت جاری، پاسخ مناسب را می‌دهد. این پیاده‌سازی باعث می‌شود که تغییرات در وضعیت سیستم به صورت منظم و کنترل‌شده انجام شود و پاسخگویی به کاربران به شکلی صحیح و دقیق صورت گیرد. این انعطاف‌پذیری و قابلیت مدیریت وضعیت‌ها به طور پویا، از دلایل اصلی انتخاب الگوی وضعیت برای این مسئله است.

<br> <br>

# سوال 4

الگوی طراحی Singleton با توجه به اصول SOLID، هر کدام از این اصول را به شکلی متفاوت تحقق می‌بخشد یا نقض می‌کند. در ادامه، تحقق یا عدم تحقق هر یک از این اصول در خصوص الگوی Singleton بررسی می‌شود.

**اصل مسئولیت یگانه (SRP)** به طور جزئی محقق می‌شود. الگوی Singleton تضمین می‌کند که تنها یک نمونه از کلاس مورد نظر وجود داشته باشد، اما اگر کلاس Singleton وظایف دیگری نیز به عهده بگیرد، ممکن است این اصل نقض شود. برای رعایت کامل SRP، کلاس Singleton باید فقط بر مدیریت نمونه متمرکز باشد و از سایر وظایف اجتناب کند.

**اصل باز/بسته (OCP)** در الگوی Singleton معمولاً محقق نمی‌شود. کلاس‌های Singleton به سختی قابل توسعه هستند و هرگونه تغییری در نحوه ایجاد یا مدیریت نمونه نیاز به تغییر مستقیم در کلاس دارد. این امر باعث می‌شود که کلاس به روی گسترش بسته و برای تغییرات باز باشد، که در تضاد با اصل OCP است.

**اصل جایگزینی لیسکوف (LSP)** در الگوی Singleton تا زمانی که به درستی یک اینترفیس یا کلاس پایه را پیاده‌سازی کند، محقق می‌شود. جایگزینی Singleton با نوع پایه خود نباید باعث ایجاد اختلال در عملکرد برنامه شود و می‌تواند بدون مشکل در برنامه مورد استفاده قرار گیرد.

**اصل تفکیک اینترفیس (ISP)** به طور مستقیم در الگوی Singleton مطرح نیست. این اصل بیشتر به طراحی اینترفیس‌ها و چگونگی استفاده از آن‌ها مربوط می‌شود تا الگوهای طراحی. از این رو، الگوی Singleton تاثیری مستقیم بر رعایت یا نقض ISP ندارد.

**اصل وارونگی وابستگی (DIP)** در الگوی Singleton اغلب نقض می‌شود. Singleton می‌تواند منجر به ایجاد وابستگی‌های قوی بین کلاس‌ها شود زیرا کلاس‌ها مستقیماً به نمونه Singleton وابسته می‌شوند. استفاده از تزریق وابستگی می‌تواند به کاهش این مشکل کمک کند، اما خود الگوی Singleton به طور پیش‌فرض از DIP پشتیبانی نمی‌کند.

در مجموع، الگوی Singleton با برخی از اصول SOLID در تناقض است و نیاز به احتیاط در استفاده از آن وجود دارد تا مانع از ایجاد مشکلات طراحی و وابستگی‌های غیرضروری شود.

<br> <br>
## سوال 5
**کد تمیز (Clean Code):** کدی که خوانا، قابل فهم و آسان برای نگهداری و توسعه باشد. <br> 
**بدهی فنی (Technical Debt):** هزینه‌های اضافی ناشی از تصمیمات سریع و ناکارآمد در فرآیند توسعه نرم‌افزار که در آینده نیاز به اصلاح دارند. <br>
**بوی بد (Code Smell):** نشانه‌هایی در کد که نشان‌دهنده وجود مشکلات پنهان است و نیاز به بهبود دارد، ولی لزوماً خطا نیستند. <br>

  <br><br>
  ## سوال 6

**انباشت ها (Bloaters):** به کدهای بیش از حد بزرگ و پیچیده‌ای اشاره دارد که به دلیل اندازه زیاد یا عناصر تکراری، نگهداری و درک آن‌ها دشوار است. <br>
**سوءاستفاده‌کنندگان از شیءگرایی (Object-Orientation Abusers):** زمانی رخ می‌دهد که توسعه‌دهندگان از ویژگی‌های شیءگرایی به درستی استفاده نمی‌کنند یا کلاس‌های غیرضروری ایجاد می‌کنند که منجر به طراحی ضعیف می‌شود. <br>
**موانع تغییر (Change Preventers):** به ساختارهای کدی اشاره دارد که تغییر یا گسترش سیستم را دشوار می‌کنند. <br>
**اضافی‌ها (Dispensables):** شامل کدهای بلااستفاده، بخش‌های کامنت‌گذاری‌شده یا متغیرها و توابع تکراری است که بدون اضافه کردن ارزش، به کد اضافه شده و آن را پیچیده می‌کنند. <br>
**جفت‌کننده‌ها (Couplers):** به کدهایی اشاره دارد که در آن وابستگی بالایی بین کلاس‌ها یا ماژول‌ها وجود دارد، به‌طوری که تغییرات در یک بخش باعث تأثیرات گسترده در سایر بخش‌ها می‌شود. <br><br>


## سوال 7
**دسته‌بندی:** بوی بد Lazy Class در دسته‌بندی "اضافی‌ها (Dispensables)" قرار می‌گیرد. <br> 

**بازآرایی‌های پیشنهادی:** برای برطرف کردن این بو، از دو تکنیک‌ زیر می‌توان استفاده کرد:<br> 
   **حذف کلاس (Remove Class):** بررسی کنید که آیا کلاس Lazy واقعاً کاربردی در کد دارد. اگر ندارد، آن را حذف کنید. <br>
   **ادغام کلاس (Inline Class):** کلاس Lazy را با کلاس دیگری که از آن استفاده می‌کند، ادغام کنید. <br> 

**زمان نادیده‌گرفتن:** این بو را می‌توان نادیده گرفت زمانی که کلاس Lazy هدف مشخص و کاربردی در کد دارد یا عملکرد آن به‌صورت واقعی مورد نیاز است، حتی اگر به نظر برسد که به‌طور کامل استفاده نمی‌شود. <br> <br> 

## سوال 8


**مورد 1 (Switch Statements):** استفاده از عبارات `switch` در کلاس `LexicalAnalyzer` که می‌تواند با الگوی استراتژی یا نقشه جایگزین شود.

**مورد 2 (Long Method):** توابعی که بیش از 30 خط کد دارند، مانند توابعی که در پروژه وجود دارند و می‌توان آن‌ها را به بخش‌های کوچکتر تقسیم کرد.

**مورد 3 (Inappropriate Intimacy):** در کلاس `ClassStructure`، نشانه‌هایی از تعاملات غیرعادی و نامناسب با دیگر کلاس‌ها وجود دارد.

**مورد 4 (Temporary Field):** در کلاس `ClassStructure`، برخی فیلدها تحت شرایطی خاص مقدار `null` می‌گیرند که نشانه‌ای از این بوی بد است.

**مورد 5 (Dead Code):** برخی از متدها، متغیرها یا حتی کلاس‌هایی که در پروژه وجود دارند اما هیچ کاربردی ندارند و به عنوان کد مرده شناخته می‌شوند.

**مورد 6 (Speculative Generality):** بخش‌هایی از کد که برای پشتیبانی از ویژگی‌های آینده که هرگز پیاده‌سازی نشده‌اند، نوشته شده‌اند.

**مورد 7 (Refused Bequest):** کلاس `ValueType` و فرزندان آن برخی از ارث‌ها را نپذیرفته‌اند که نشانه‌ای از این بوی بد است.

**مورد 8 (Data Class):** کلاس `ClassNode` به عنوان یک کلاس داده‌ای عمل می‌کند و فقط شامل داده‌ها است بدون هیچ‌گونه رفتار مشخص.

**مورد 9 (Large Class):** کلاس‌هایی مانند `Phase2CodeFileManipulator` که 576 خط کد دارد و به عنوان یک کلاس بزرگ محسوب می‌شود.

**مورد 10 (Feature Envy):** کلاس‌هایی که به طور مکرر به داده‌ها و متدهای سایر کلاس‌ها دسترسی دارند، نشانه‌ای از این بوی بد است. <br> <br>

## سوال 9 
پلاگین **formatter-maven-plugin** یک پلاگین Maven است که به توسعه‌دهندگان اجازه می‌دهد تا کد منبع جاوا را با استفاده از فرمت‌کننده کد Eclipse به‌صورت خودکار قالب‌بندی کنند. هدف اصلی این پلاگین، خودکارسازی فرآیند قالب‌بندی کد برای پیروی از یک سبک کدنویسی یکپارچه است. 

قالب‌بندی یکپارچه کد باعث می‌شود که کد پایه خواناتر و قابل نگهداری‌تر باشد و نویزهای بصری و مشکلات قالب‌بندی، مانند تورفتگی نادرست یا فاصله‌گذاری‌های نامناسب، حذف شوند. 

این پلاگین به توسعه‌دهندگان کمک می‌کند تا قوانین قالب‌بندی مورد نظر خود را تعریف کرده و آن‌ها را به‌طور خودکار در حین فرآیند ساخت پروژه اعمال کنند. این موضوع مخصوصاً در پروژه‌های بزرگ و همکاری‌های چند نفره مفید است، زیرا تضمین می‌کند که کل کد پایه از قوانین قالب‌بندی مشخصی پیروی می‌کند.

**ارتباط با بازآرایی کد:** 
بازآرایی کد (Refactoring) به معنی تغییر ساختار کد بدون تغییر در عملکرد آن است، و هدف از آن بهبود خوانایی، نگهداری و گسترش‌پذیری کد است. پلاگین formatter می‌تواند در این فرآیند نقش مهمی ایفا کند، زیرا پس از هر بازآرایی، می‌توان از این ابزار برای اطمینان از اینکه قالب‌بندی کد به همان سبک یکپارچه قبلی باقی مانده است، استفاده کرد. این کار باعث می‌شود که تغییرات ساختاری ایجاد شده به وضوح دیده شوند و تأثیرات آن‌ها بر روی کد بهتر قابل بررسی باشد.
